---
title: "Import des archives GENSRA et génération de tableaux de bord"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{generation-tableaux-de-bord-pmsi}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  eval = TRUE,
  echo = TRUE,
  warning=FALSE,
  results = 'markup'
)
```

```{r setup}
library(pmeasyr)
library(tidyverse)
library (RCurl)
library(jsonlite)
library(referentiels)
library(nomensland)
library(readxl)
library(dimRactivite)
```

Les fonctions d'imports et d'analyses sont construites sur le principe que chaque établissement produit tous les mois des fichiers de données de facturation mis en entrée du logiciel ATIH GENRSA utilisé pour transmettre les données PMSI aux tutelles.  L’analyse de ces fichiers par GENRSA produit 2 types d’archives (.zip) le in (les fichiers d’entrée) et le out (fichiers préparés pour être envoyés). Le package généralise l’import des fichiers zippés en sortie de GENRSA (in et out) dans un environnement de travail R permettant l’analyse des données et la production de tableaux de bord automatiques.

# Import des données dans R

### Paramètre des imports
Le paramètres nécessaires pour les imports se trouvent dans un le fichier options.yaml (cf exemple) en particulier la variable ```path``` qui donne le chemin du dossier racine dans le quel se trouve les archives PMSI en sortie de GENRSA.
```{r profondeur}

dimRactivite::update_options('options.yaml')

profondeur_imports = 2
```
### Création des fichiers .RData par remontée

#### Analyse des fichiers en fonction de leur extentions (ext imco + .zip) et vérification de la présence des .RData

La première étape consiste à scanner le dossier contenant les archives afin de dresser la liste de remontées disponibles ce qui produit un tableaux de données référençant l'ensemble des informations utiles sur les archives et leur contenu. Ce tableau appelé ```fichiers_genrsa``` sera utilisé par les autres fonctions d'imports comme reférentiel pour décrire les données disponibles. Il est sauvegardé dans les options. 

Les fichiers sont ensuite analysés afin de préparer la création (ou non) des fichiers .RData. On vérifie la présence dans les fichiers zippés en entrée et en sortie de GENRSA de l'ensemble des fichiers nécessaires à la facturation et à l'analyse de l'activité en lisant l'extension des fichiers de l'archive. La (sous) fonction ```analyse_fichiers_remontees``` produit un dataframe ```remontees_dispo``` de synthèse où pour chaque remontée on liste l'absence (0) ou la présence (1) des fichiers qui seront utilisés. Ce dataframe sera également utilisé pour les autres fonctions.


```{r analyse_dossier_remontees}
remontees_dispo <- dimRactivite::analyse_dossier_remontees( maj_dernier_mois = FALSE )
#Voir la liste des fichiers RData non disponibles qui seront générés à l'étape suivante
print( remontees_dispo %>% filter( RData != 1 ) )

```

#### Création et sauvegarde des .RData de remontée (si manquant) et mise à jour de la liste des remontées disponibles

La fonction ```save_remontee``` prend comme argument le tableau de synthèse des fichiers diponibles dans le dossier racine (```remontees_dispo```) et produit un fichier .RData pour chaque remontée, qui est enregisté dans le dossier racine. Pour être importée, une remontée doit comprendre le in et le out de GENRSA. Les fichiers indispensables sont le .rss et le .rsa. S'ils ne sont pas présents dans l'archive les autres fichiers servant à la facturation seront générés automatiquement (fichier vide). Les remontées pour lequelles un fichier .RData est disponible ne seront pas ré-importés.

Par défaut, l'option ```option recent = TRUE``` induit la création du .RData pour la dernière remontée disponible en forçant la variable .RData du tableau de données ```remontees_dispo``` à 0 (même si un fichier .RData est disponible pour cette remontée dans le dossier racine).


```{r save_remontee}
remontees_dispo <- dimRactivite::save_remontees( remontees_dispo )
```


### Import dans l'environement de travail

#### RUM, RSA, ANO et des données de valorisation

Les données peuvent ensuite être importées dans la mémoire de R. Par défaut on choisit le M12 des années antérieures et le dernier mois pour l'année en cours.

```{r sel_remontees_import}

sel_remontees_import<-remontees_dispo%>%filter( as.numeric(annee) > max( as.numeric(remontees_dispo$annee) ) - profondeur_imports, RData == 1 )%>%
  mutate( mois  =  as.numeric(mois) )%>%
  group_by( finess, annee )%>% filter( mois == max(mois) )

```
Le df ```sel_remontees_import``` est passé en argument de la fonction ```load_all()``` qui permet le chargment des données. Le paramètre ```extra = TRUE``` permet de charger des tableaux de données complémentaires utiles pour l'analyse :
- rsa_v_nonconsol et rum_v_nonconsol : données non consolidées à la date de la remontée pour l'année N-1 (vs M12 classiquement utilisées dans les analyses)
- rsa_v_tarifsante, rum_v_tarifsante : données N valorisées avec les tarifs de l'année N-1

```{r load_sejours}
dimRactivite::load_RData( sel_remontees_import, extra = TRUE  )
```

#### Import des fichiers MO et DMI
```{r load_med_dmi}
load_med( sel_remontees_import )
load_dmi( sel_remontees_import )
```
#### Ajout des données de struture

Différentes données complémentaires peuvent ensuite être ajoutées aux données PMSI standardisées. L'ajout d'élements descriptifs des uma (leur libellé, services et pôles de rattachement) sera probablement le plus important d'entre eux. L'ajout des structures se fait grâce à un fichier de paramètres ```structure.xls``` (cf exemple).

La fonction ```verif_structure()``` permet de s'assurer que l'ensemble des uma présentes dans les fichiers GENRSA sont bien renseignées dans le fichier structure.

```{r Chargement du fichier structure}

# ajout des structures dans les rum
structures <- readxl::read_excel(getOption("dimRactivite.structures"),
                                        col_types = c( "text" , "text" , "text" , "text" , "text", "text" ),
                                        col_names = c('nofiness','hopital','cdurm','libelle_um','service','pole'),
                                        skip = 1
)
#vérification que toutes les UMA sont bien renseignées dans le fichier structure
#dimRactivite::verif_structure(rum,fichier_structure)

rum <- rum%>%select(-nofiness) %>% # pour simulation structures fictives avec finess ficitif
  left_join( ., structures ) %>%
          mutate( pole = ifelse(is.na(pole), 'Erreurs', pole ),
                  service = ifelse(is.na(service), 'Erreur service non renseigné', service ) )

```

```{r Echantillon}
rum <- rum  %>% sample_n(., 10000, replace = FALSE)

```

On pourrait à cet endroit, vouloir également ajouter d'autres informations sur les RUM comme par exemple l'identité des patients.

# Génération des tableaux de bord

Deux types de tableaux de bord peuvent être générés (les exemples donnés ici ne sont accéssibles que sur l'intranet de l'APHP) :
- des tableaux synthétiques permettant une vue de l'évolution temporelle d'un indicateur pour l'ensemble de l'établissement ou du groupe hospitalier  (ex : [intranet aphp](http://msi.sls.aphp.fr/tdb/index.php?_tbl=TableauDeBordGeneral&_mois=07&_annee=2019&_type=mens) ), des recettes avec une répartition par service (ex : [intranet aphp](http://msi.sls.aphp.fr/tdb/index.php?_tbl=TableauDeBordValorisation&_mois=07&_annee=2019&_type=mens) )
- des tableaux détaillés pour chaque niveau du fichier structure permettant de suivre l'évolution temporelle pour ce niveau d'un ensemble d'indicateurs prédéfinis (ex [intranet aphp](http://msi.sls.aphp.fr/tdb/index.php?_tbl=TableauDeBordActivite&_service=Lariboisiere&_mois=07&_annee=2019&_type=mens)).

Pour l'ensemble de ces tableaux on produit une version mensuelle et une version cumulée. La fonction ```get_data()``` permet de préparer les données.

### Paramètres des tableaux de bord

Pour les tableaux détaillés, un fichier de paramétrage permet de définir quels indicateurs calculés pour chaque élément du fichier structure (par ex. le suivi de l'activité des services de réanimation nécessitera le suivi d'indicateurs différents que ceux des services de médecine). Sachant que le nombre d'indicateurs calculés aujourd'hui est important (de l'ordre de 200) nous avons également laisser la possibilité de découper les résultats en différents tableaux.

L'option ```profondeur_tdb``` permet de définir la profondeur temporelle, en année, du suivi des tableaux de bord. D'autres données de références sont également utiles commes les dms de référence dans la base nationale pmsi ou des listes de disgnostics. Elles sont chargées grâce aux package ```referime``` et ```referentiel```.

```{r Chargement du annee mois en cours}

#Chemins pour les sorties écriture des fichiers de sortie
path_res = getwd()

#Année et mois en cours
mois=as.numeric(format(Sys.Date()-50,'%m'));Mois=format(Sys.Date()-50,'%m')
annee=as.numeric(format(Sys.Date()-55,'%Y'))

#Profondeur de calcul
profondeur_tdb = 2

#### Import des paramètres des tableaux 
ghm_dms_nationales<-nomensland::get_table("ghm_dms_nationales")

#Merge rsa, dms pour les cas ou la référence dans ghm_dms_nationales = ghs
rsa_dms1<-dplyr::inner_join( rsa %>% unite("ghm",gpcmd,gptype,gpnum,gpcompx,sep="")%>%
                       rename( ghs = noghs )%>%
                       select( nofiness, cle_rsa, ansor, anseqta, ghs, ghm ),
                     ghm_dms_nationales%>%filter(ghs!=""))
#Merge rsa, dms pour les cas ou la référence dans ghm_dms_nationales = ghm
rsa_dms2 <- dplyr::inner_join( rsa %>% unite("ghm", gpcmd, gptype, gpnum, gpcompx, sep="" )%>%
                       select( nofiness, cle_rsa, ansor, anseqta, ghm ),
                     ghm_dms_nationales %>% filter( ghs=="" ) )
rsa_dms <- dplyr::bind_rows( rsa_dms1 %>% select( nofiness, cle_rsa, ansor, dms_n ),
                   rsa_dms2 %>% select( nofiness, cle_rsa, ansor, dms_n )
                   )
rm( rsa_dms1, rsa_dms2 ) 


#### Import des paramètres (liste des indicateurs à calculer pour chaque niveau du fichier structure)
references<-read.table('indicateurs.xls',
                       sep='\t',
                       header=F,fill=T,
                       na.strings = c("NA",""),stringsAsFactor=F,fileEncoding = 'latin1')

names(references)<-dimRactivite:::prep_string(references[1,])
references<-references[-1,]%>%as_tibble(.)
#labels = df simple avec les légendes
labels<-as.data.frame(references[!duplicated(references$var),c('var','libelle','niv')])
row.names(labels)<-labels$var
labels<-labels[,-1]

#Présents dans fichiers structure, absent référentiels
#dimRactivite:::prep_string(str)[!dimRactivite:::prep_string(str)%in%names(references)]
#Présents référentiels, absents fichier structure
#names(references)[!names(references)%in%c(dimRactivite:::prep_string(str),'tdb','niv','libelle','var','variable','dataframe','referentiel')]


#####################################################################################################################
#Prération des données pour le suivi de l'activité de cancérologie
#####################################################################################################################
cancer_diag <- dimRactivite:::selection_cancer_diag(diagnostics)
cancer_pat <- dimRactivite:::selection_cancer_pat(cancer_diag , vano%>%inner_join(., rum%>%select(nofiness,cle_rsa,ansor,nas)) %>%
                                     select( nas, noanon ) %>%
                                     distinct(nas,noanon))
cancer_rsa <- dplyr::inner_join(cancer_pat,
                                rsa%>%inner_join(., vano%>%select(nofiness,cle_rsa,ansor,noanon))%>%
                                  select(noanon,nofiness,cle_rsa,ansor, moissor, nas, dp, gpcmd, gptype, gpnum, gpcompx))%>%
  dimRactivite:::attribution_type_M4(.)%>%
  dimRactivite:::attribution_statut_nx_patient(.)


```
```{r test}
table(rum$service)
```

### Génération des tableaux de bord synthétiques

```{r tableaux de bord synthetiques }

df<-dimRactivite::get_data(inner_join(rum,rum_v), a =(annee-profondeur_tdb):annee, m = 1:mois )


tdb <- dimRactivite::get_activite_sejours( df, structures )
path_file=paste0('TableauDeBordGeneral',annee,stringr::str_pad(mois,2,"left","0"),'cum.xls')  
write.table( tdb, file=path_file, sep='\t', row.names=T, col.names=NA, na='' , fileEncoding = "utf-8" )

tdb <- dimRactivite::get_activite_recettes( df, structures )
path_file=paste0('TableauDeBordValorisation',annee,stringr::str_pad(mois,2,"left","0"),'cum.xls')  
write.table( tdb, file=path_file, sep='\t', row.names=T, col.names=NA, na='' , fileEncoding = "utf-8" )


df <- df %>% filter( as.numeric(moissor) == mois )

tdb <- dimRactivite::get_activite_sejours( df, structures )
path_file=paste0('TableauDeBordGeneral',annee,stringr::str_pad(mois,2,"left","0"),'mens.xls')  
write.table( tdb, file=path_file, sep='\t', row.names=T, col.names=NA, na='' , fileEncoding = "utf-8" )

tdb <- dimRactivite::get_activite_recettes( df, structures )
path_file=paste0('TableauDeBordValorisation',annee,stringr::str_pad(mois,2,"left","0"),'mens.xls')  
write.table( tdb, file=path_file, sep='\t', row.names=T, col.names=NA, na='' , fileEncoding = "utf-8" )


``` 


### Génération des tableaux de bord détaillés

```{r tableaux de bord détaillés}
tdb<-list()
#######################################################################################################################
#Tableaux de bords thématiques
#######################################################################################################################
niveau = "hopital"
vals = fichier_structure%>%select(!!niveau)%>%unique()%>%flatten_chr()

for (val in vals ){
  
  tdb[[val]]<-dimRactivite::make_tdb( val, niveau, annee, mois )
  
}


niveau = "pole"
vals = fichier_structure%>%select(!!niveau)%>%unique()%>%flatten_chr()

for (val in vals ){
  
  tdb[[val]]<-dimRactivite::make_tdb( val, niveau, annee, mois )
  
}


#niveau = "service"
vals = fichier_structure%>%select(!!niveau)%>%unique()%>%flatten_chr()

for ( val in vals ){
  
  tdb[[val]]<-dimRactivite::make_tdb( val, niveau, annee, mois )
  
}


```


